
-- Parsing `protocol.v' using frontend `verilog' --

1. Executing Verilog-2005 frontend: protocol.v
Parsing Verilog input from `protocol.v' to AST representation.
Generating RTLIL representation for module `\protocol'.
Successfully finished Verilog frontend.

-- Parsing `uart_rx.v' using frontend `verilog' --

2. Executing Verilog-2005 frontend: uart_rx.v
Parsing Verilog input from `uart_rx.v' to AST representation.
Generating RTLIL representation for module `\uart_rx'.
Successfully finished Verilog frontend.

-- Parsing `uart_tx.v' using frontend `verilog' --

3. Executing Verilog-2005 frontend: uart_tx.v
Parsing Verilog input from `uart_tx.v' to AST representation.
Generating RTLIL representation for module `\uart_tx'.
Successfully finished Verilog frontend.

-- Parsing `baudgen_rx.v' using frontend `verilog' --

4. Executing Verilog-2005 frontend: baudgen_rx.v
Parsing Verilog input from `baudgen_rx.v' to AST representation.
Generating RTLIL representation for module `\baudgen_rx'.
Successfully finished Verilog frontend.

-- Parsing `baudgen.v' using frontend `verilog' --

5. Executing Verilog-2005 frontend: baudgen.v
Parsing Verilog input from `baudgen.v' to AST representation.
Generating RTLIL representation for module `\baudgen'.
Successfully finished Verilog frontend.

-- Parsing `mods.v' using frontend `verilog' --

6. Executing Verilog-2005 frontend: mods.v
Parsing Verilog input from `mods.v' to AST representation.
Generating RTLIL representation for module `\ram_mem'.
Generating RTLIL representation for module `\bin_to_hexa'.
Note: Assuming pure combinatorial block at mods.v:34 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Generating RTLIL representation for module `\hexa_to_bin'.
Generating RTLIL representation for module `\cmd_control'.
Generating RTLIL representation for module `\decode_cmd'.
Note: Assuming pure combinatorial block at mods.v:173 in
compliance with IEC 62142(E):2005 / IEEE Std. 1364.1(E):2002. Recommending
use of @* instead of @(...) for better match of synthesis and simulation.
Successfully finished Verilog frontend.

-- Running command `synth_ice40  -json protocol.json' --

7. Executing SYNTH_ICE40 pass.

7.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/usr/bin/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Successfully finished Verilog frontend.

7.2. Executing HIERARCHY pass (managing design hierarchy).

7.2.1. Finding top of design hierarchy..
root of   0 design levels: decode_cmd          
root of   0 design levels: cmd_control         
root of   0 design levels: hexa_to_bin         
root of   0 design levels: bin_to_hexa         
root of   0 design levels: ram_mem             
root of   0 design levels: baudgen             
root of   0 design levels: baudgen_rx          
root of   1 design levels: uart_tx             
root of   1 design levels: uart_rx             
root of   2 design levels: protocol            
Automatically selected protocol as design top module.

7.2.2. Analyzing design hierarchy..
Top module:  \protocol
Used module:     \cmd_control
Used module:     \decode_cmd
Used module:     \bin_to_hexa
Used module:     \hexa_to_bin
Used module:     \ram_mem
Used module:     \uart_tx
Used module:         \baudgen
Used module:     \uart_rx
Used module:         \baudgen_rx

7.2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\uart_tx'.
Parameter 1 (\BAUD) = 104
Generating RTLIL representation for module `$paramod\uart_tx\BAUD=104'.

7.2.4. Executing AST frontend in derive mode using pre-parsed AST for module `\uart_rx'.
Parameter 1 (\BAUD) = 104
Generating RTLIL representation for module `$paramod\uart_rx\BAUD=104'.

7.2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\baudgen'.
Parameter \BAUD = 104
Generating RTLIL representation for module `$paramod\baudgen\BAUD=104'.

7.2.6. Executing AST frontend in derive mode using pre-parsed AST for module `\baudgen_rx'.
Parameter \BAUD = 104
Generating RTLIL representation for module `$paramod\baudgen_rx\BAUD=104'.

7.2.7. Analyzing design hierarchy..
Top module:  \protocol
Used module:     \cmd_control
Used module:     \decode_cmd
Used module:     \bin_to_hexa
Used module:     \hexa_to_bin
Used module:     \ram_mem
Used module:     $paramod\uart_tx\BAUD=104
Used module:         \baudgen
Used module:     $paramod\uart_rx\BAUD=104
Used module:         \baudgen_rx

7.2.8. Executing AST frontend in derive mode using pre-parsed AST for module `\baudgen'.
Parameter \BAUD = 104
Found cached RTLIL representation for module `$paramod\baudgen\BAUD=104'.

7.2.9. Executing AST frontend in derive mode using pre-parsed AST for module `\baudgen_rx'.
Parameter \BAUD = 104
Found cached RTLIL representation for module `$paramod\baudgen_rx\BAUD=104'.

7.2.10. Analyzing design hierarchy..
Top module:  \protocol
Used module:     \cmd_control
Used module:     \decode_cmd
Used module:     \bin_to_hexa
Used module:     \hexa_to_bin
Used module:     \ram_mem
Used module:     $paramod\uart_tx\BAUD=104
Used module:         $paramod\baudgen\BAUD=104
Used module:     $paramod\uart_rx\BAUD=104
Used module:         $paramod\baudgen_rx\BAUD=104

7.2.11. Analyzing design hierarchy..
Top module:  \protocol
Used module:     \cmd_control
Used module:     \decode_cmd
Used module:     \bin_to_hexa
Used module:     \hexa_to_bin
Used module:     \ram_mem
Used module:     $paramod\uart_tx\BAUD=104
Used module:         $paramod\baudgen\BAUD=104
Used module:     $paramod\uart_rx\BAUD=104
Used module:         $paramod\baudgen_rx\BAUD=104
Removing unused module `\baudgen'.
Removing unused module `\baudgen_rx'.
Removing unused module `\uart_tx'.
Removing unused module `\uart_rx'.
Removed 4 unused modules.
Mapping positional arguments of cell protocol.cctrl (cmd_control).
Mapping positional arguments of cell protocol.dcmd (decode_cmd).
Mapping positional arguments of cell protocol.bth2 (bin_to_hexa).
Mapping positional arguments of cell protocol.bth1 (bin_to_hexa).
Mapping positional arguments of cell protocol.htb (hexa_to_bin).
Mapping positional arguments of cell protocol.ram_mem_wen01 (ram_mem).

7.3. Executing PROC pass (convert processes to netlists).

7.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `ram_mem.$proc$mods.v:15$123'.
Cleaned up 0 empty switches.

7.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$mods.v:173$151 in module decode_cmd.
Marked 1 switch rules as full_case in process $proc$mods.v:134$126 in module cmd_control.
Marked 1 switch rules as full_case in process $proc$mods.v:63$125 in module hexa_to_bin.
Removed 1 dead cases from process $proc$mods.v:34$124 in module bin_to_hexa.
Marked 1 switch rules as full_case in process $proc$mods.v:34$124 in module bin_to_hexa.
Marked 1 switch rules as full_case in process $proc$baudgen_rx.v:44$211 in module $paramod\baudgen_rx\BAUD=104.
Marked 1 switch rules as full_case in process $proc$baudgen.v:40$203 in module $paramod\baudgen\BAUD=104.
Removed 1 dead cases from process $proc$uart_rx.v:100$190 in module $paramod\uart_rx\BAUD=104.
Marked 4 switch rules as full_case in process $proc$uart_rx.v:100$190 in module $paramod\uart_rx\BAUD=104.
Marked 1 switch rules as full_case in process $proc$uart_rx.v:83$188 in module $paramod\uart_rx\BAUD=104.
Marked 1 switch rules as full_case in process $proc$uart_rx.v:77$186 in module $paramod\uart_rx\BAUD=104.
Marked 1 switch rules as full_case in process $proc$uart_rx.v:67$181 in module $paramod\uart_rx\BAUD=104.
Marked 4 switch rules as full_case in process $proc$uart_tx.v:124$170 in module $paramod\uart_tx\BAUD=104.
Marked 1 switch rules as full_case in process $proc$uart_tx.v:91$163 in module $paramod\uart_tx\BAUD=104.
Marked 2 switch rules as full_case in process $proc$uart_tx.v:74$157 in module $paramod\uart_tx\BAUD=104.
Marked 7 switch rules as full_case in process $proc$protocol.v:105$7 in module protocol.
Removed a total of 2 dead cases.

7.3.3. Executing PROC_INIT pass (extract init attributes).
Found init rule in `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:41$218'.
  Set init value: \divcounter = 7'0000000
Found init rule in `$paramod\baudgen\BAUD=104.$proc$baudgen.v:37$210'.
  Set init value: \divcounter = 7'0000000
Found init rule in `\protocol.$proc$protocol.v:73$47'.
  Set init value: \wen = 1'0
Found init rule in `\protocol.$proc$protocol.v:34$46'.
  Set init value: \rstn = 1'0

7.3.4. Executing PROC_ARST pass (detect async resets in processes).

7.3.5. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\decode_cmd.$proc$mods.v:173$151'.
     1/1: $0\code[15:0]
Creating decoders for process `\cmd_control.$proc$mods.v:134$126'.
     1/1: { $0\r_s_m[0:0] $0\r_e_m[0:0] $0\r_m_m[0:0] }
Creating decoders for process `\hexa_to_bin.$proc$mods.v:63$125'.
     1/1: $0\d_out_4[3:0]
Creating decoders for process `\bin_to_hexa.$proc$mods.v:34$124'.
     1/2: $1\ascii[7:0]
     2/2: $0\ascii[7:0]
Creating decoders for process `\ram_mem.$proc$mods.v:21$116'.
     1/4: $0\dout[7:0]
     2/4: $0$memwr$\mem$mods.v:24$115_EN[7:0]$119
     3/4: $0$memwr$\mem$mods.v:24$115_DATA[7:0]$118
     4/4: $0$memwr$\mem$mods.v:24$115_ADDR[8:0]$117
Creating decoders for process `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:41$218'.
     1/1: $1\divcounter[6:0]
Creating decoders for process `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:44$211'.
     1/1: $0\divcounter[6:0]
Creating decoders for process `$paramod\baudgen\BAUD=104.$proc$baudgen.v:37$210'.
     1/1: $1\divcounter[6:0]
Creating decoders for process `$paramod\baudgen\BAUD=104.$proc$baudgen.v:40$203'.
     1/1: $0\divcounter[6:0]
Creating decoders for process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:138$194'.
     1/4: $0\rcv[0:0]
     2/4: $0\load[0:0]
     3/4: $0\clear[0:0]
     4/4: $0\bauden[0:0]
Creating decoders for process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:100$190'.
     1/1: $0\state[1:0]
Creating decoders for process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:83$188'.
     1/1: $0\data[7:0]
Creating decoders for process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:77$186'.
     1/2: $1\raw_data[9:0]
     2/2: $0\raw_data[9:0]
Creating decoders for process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:67$181'.
     1/1: $0\bitc[3:0]
Creating decoders for process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:53$180'.
     1/1: $0\rx_r[0:0]
Creating decoders for process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:124$170'.
     1/1: $0\state[1:0]
Creating decoders for process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:100$169'.
     1/1: $0\tx[0:0]
Creating decoders for process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:91$163'.
     1/1: $0\bitc[3:0]
Creating decoders for process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:74$157'.
     1/1: $0\shifter[9:0]
Creating decoders for process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:62$153'.
     1/1: $0\data_r[7:0]
Creating decoders for process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:59$152'.
     1/1: $0\start_r[0:0]
Creating decoders for process `\protocol.$proc$protocol.v:73$47'.
     1/1: $2\wen[0:0]
Creating decoders for process `\protocol.$proc$protocol.v:34$46'.
     1/1: $1\rstn[0:0]
Creating decoders for process `\protocol.$proc$protocol.v:165$9'.
     1/8: $1\data_mem[7:0] [7:4]
     2/8: $1\data_mem[7:0] [3:0]
     3/8: $1\r_tx_msb[7:0]
     4/8: $1\r_command_code[15:0]
     5/8: $1\r_tx_lsb[7:0]
     6/8: $0\mem_address[3:0]
     7/8: $1\wen[0:0]
     8/8: $1\tx_data[7:0]
Creating decoders for process `\protocol.$proc$protocol.v:105$7'.
     1/10: $0\r_tx_lsb[7:0]
     2/10: $0\r_tx_msb[7:0]
     3/10: $0\r_tx_address[7:0]
     4/10: $0\r_tx_command[7:0]
     5/10: $0\r_command_code[15:0]
     6/10: $0\rx_state[3:0]
     7/10: $0\data_mem[7:0]
     8/10: $0\mem_address[8:0]
     9/10: $0\wen[0:0]
    10/10: $0\tx_data[7:0]
Creating decoders for process `\protocol.$proc$protocol.v:59$2'.
     1/1: $0\leds[3:0]
Creating decoders for process `\protocol.$proc$protocol.v:39$1'.
     1/1: $0\rstn[0:0]

7.3.6. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\decode_cmd.\code' from process `\decode_cmd.$proc$mods.v:173$151'.
No latch inferred for signal `\cmd_control.\r_s_m' from process `\cmd_control.$proc$mods.v:134$126'.
No latch inferred for signal `\cmd_control.\r_e_m' from process `\cmd_control.$proc$mods.v:134$126'.
No latch inferred for signal `\cmd_control.\r_m_m' from process `\cmd_control.$proc$mods.v:134$126'.
No latch inferred for signal `\hexa_to_bin.\d_out_4' from process `\hexa_to_bin.$proc$mods.v:63$125'.
Latch inferred for signal `\bin_to_hexa.\ascii' from process `\bin_to_hexa.$proc$mods.v:34$124': $auto$proc_dlatch.cc:409:proc_dlatch$538
No latch inferred for signal `$paramod\uart_rx\BAUD=104.\clear' from process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:138$194'.
No latch inferred for signal `$paramod\uart_rx\BAUD=104.\rcv' from process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:138$194'.
No latch inferred for signal `$paramod\uart_rx\BAUD=104.\bauden' from process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:138$194'.
No latch inferred for signal `$paramod\uart_rx\BAUD=104.\load' from process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:138$194'.

7.3.7. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\ram_mem.\dout' using process `\ram_mem.$proc$mods.v:21$116'.
  created $dff cell `$procdff$539' with positive edge clock.
Creating register for signal `\ram_mem.$memwr$\mem$mods.v:24$115_ADDR' using process `\ram_mem.$proc$mods.v:21$116'.
  created $dff cell `$procdff$540' with positive edge clock.
Creating register for signal `\ram_mem.$memwr$\mem$mods.v:24$115_DATA' using process `\ram_mem.$proc$mods.v:21$116'.
  created $dff cell `$procdff$541' with positive edge clock.
Creating register for signal `\ram_mem.$memwr$\mem$mods.v:24$115_EN' using process `\ram_mem.$proc$mods.v:21$116'.
  created $dff cell `$procdff$542' with positive edge clock.
Creating register for signal `$paramod\baudgen_rx\BAUD=104.\divcounter' using process `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:44$211'.
  created $dff cell `$procdff$543' with positive edge clock.
Creating register for signal `$paramod\baudgen\BAUD=104.\divcounter' using process `$paramod\baudgen\BAUD=104.$proc$baudgen.v:40$203'.
  created $dff cell `$procdff$544' with positive edge clock.
Creating register for signal `$paramod\uart_rx\BAUD=104.\state' using process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:100$190'.
  created $dff cell `$procdff$545' with positive edge clock.
Creating register for signal `$paramod\uart_rx\BAUD=104.\data' using process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:83$188'.
  created $dff cell `$procdff$546' with positive edge clock.
Creating register for signal `$paramod\uart_rx\BAUD=104.\raw_data' using process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:77$186'.
  created $dff cell `$procdff$547' with positive edge clock.
Creating register for signal `$paramod\uart_rx\BAUD=104.\bitc' using process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:67$181'.
  created $dff cell `$procdff$548' with positive edge clock.
Creating register for signal `$paramod\uart_rx\BAUD=104.\rx_r' using process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:53$180'.
  created $dff cell `$procdff$549' with positive edge clock.
Creating register for signal `$paramod\uart_tx\BAUD=104.\state' using process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:124$170'.
  created $dff cell `$procdff$550' with positive edge clock.
Creating register for signal `$paramod\uart_tx\BAUD=104.\tx' using process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:100$169'.
  created $dff cell `$procdff$551' with positive edge clock.
Creating register for signal `$paramod\uart_tx\BAUD=104.\bitc' using process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:91$163'.
  created $dff cell `$procdff$552' with positive edge clock.
Creating register for signal `$paramod\uart_tx\BAUD=104.\shifter' using process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:74$157'.
  created $dff cell `$procdff$553' with positive edge clock.
Creating register for signal `$paramod\uart_tx\BAUD=104.\data_r' using process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:62$153'.
  created $dff cell `$procdff$554' with positive edge clock.
Creating register for signal `$paramod\uart_tx\BAUD=104.\start_r' using process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:59$152'.
  created $dff cell `$procdff$555' with positive edge clock.
Creating register for signal `\protocol.\tx_data' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$556' with positive edge clock.
Creating register for signal `\protocol.\wen' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$557' with positive edge clock.
Creating register for signal `\protocol.\mem_address [3:0]' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$558' with positive edge clock.
Creating register for signal `\protocol.\data_mem' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$559' with positive edge clock.
Creating register for signal `\protocol.\r_command_code' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$560' with positive edge clock.
Creating register for signal `\protocol.\r_tx_msb' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$561' with positive edge clock.
Creating register for signal `\protocol.\r_tx_lsb' using process `\protocol.$proc$protocol.v:165$9'.
  created $dff cell `$procdff$562' with positive edge clock.
Creating register for signal `\protocol.\tx_data' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$563' with positive edge clock.
Creating register for signal `\protocol.\wen' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$564' with positive edge clock.
Creating register for signal `\protocol.\mem_address' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$565' with positive edge clock.
Creating register for signal `\protocol.\data_mem' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$566' with positive edge clock.
Creating register for signal `\protocol.\rx_state' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$567' with positive edge clock.
Creating register for signal `\protocol.\r_command_code' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$568' with positive edge clock.
Creating register for signal `\protocol.\r_tx_command' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$569' with positive edge clock.
Creating register for signal `\protocol.\r_tx_address' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$570' with positive edge clock.
Creating register for signal `\protocol.\r_tx_msb' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$571' with positive edge clock.
Creating register for signal `\protocol.\r_tx_lsb' using process `\protocol.$proc$protocol.v:105$7'.
  created $dff cell `$procdff$572' with positive edge clock.
Creating register for signal `\protocol.\leds' using process `\protocol.$proc$protocol.v:59$2'.
  created $dff cell `$procdff$573' with positive edge clock.
Creating register for signal `\protocol.\rstn' using process `\protocol.$proc$protocol.v:39$1'.
  created $dff cell `$procdff$574' with positive edge clock.

7.3.8. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\decode_cmd.$proc$mods.v:173$151'.
Removing empty process `decode_cmd.$proc$mods.v:173$151'.
Found and cleaned up 1 empty switch in `\cmd_control.$proc$mods.v:134$126'.
Removing empty process `cmd_control.$proc$mods.v:134$126'.
Found and cleaned up 1 empty switch in `\hexa_to_bin.$proc$mods.v:63$125'.
Removing empty process `hexa_to_bin.$proc$mods.v:63$125'.
Found and cleaned up 1 empty switch in `\bin_to_hexa.$proc$mods.v:34$124'.
Removing empty process `bin_to_hexa.$proc$mods.v:34$124'.
Found and cleaned up 1 empty switch in `\ram_mem.$proc$mods.v:21$116'.
Removing empty process `ram_mem.$proc$mods.v:21$116'.
Removing empty process `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:41$218'.
Found and cleaned up 1 empty switch in `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:44$211'.
Removing empty process `$paramod\baudgen_rx\BAUD=104.$proc$baudgen_rx.v:44$211'.
Removing empty process `$paramod\baudgen\BAUD=104.$proc$baudgen.v:37$210'.
Found and cleaned up 1 empty switch in `$paramod\baudgen\BAUD=104.$proc$baudgen.v:40$203'.
Removing empty process `$paramod\baudgen\BAUD=104.$proc$baudgen.v:40$203'.
Removing empty process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:138$194'.
Found and cleaned up 4 empty switches in `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:100$190'.
Removing empty process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:100$190'.
Found and cleaned up 2 empty switches in `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:83$188'.
Removing empty process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:83$188'.
Found and cleaned up 1 empty switch in `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:77$186'.
Removing empty process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:77$186'.
Found and cleaned up 2 empty switches in `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:67$181'.
Removing empty process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:67$181'.
Removing empty process `$paramod\uart_rx\BAUD=104.$proc$uart_rx.v:53$180'.
Found and cleaned up 4 empty switches in `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:124$170'.
Removing empty process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:124$170'.
Removing empty process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:100$169'.
Found and cleaned up 2 empty switches in `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:91$163'.
Removing empty process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:91$163'.
Found and cleaned up 3 empty switches in `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:74$157'.
Removing empty process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:74$157'.
Found and cleaned up 1 empty switch in `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:62$153'.
Removing empty process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:62$153'.
Removing empty process `$paramod\uart_tx\BAUD=104.$proc$uart_tx.v:59$152'.
Removing empty process `protocol.$proc$protocol.v:73$47'.
Removing empty process `protocol.$proc$protocol.v:34$46'.
Found and cleaned up 10 empty switches in `\protocol.$proc$protocol.v:165$9'.
Removing empty process `protocol.$proc$protocol.v:165$9'.
Found and cleaned up 8 empty switches in `\protocol.$proc$protocol.v:105$7'.
Removing empty process `protocol.$proc$protocol.v:105$7'.
Found and cleaned up 1 empty switch in `\protocol.$proc$protocol.v:59$2'.
Removing empty process `protocol.$proc$protocol.v:59$2'.
Removing empty process `protocol.$proc$protocol.v:39$1'.
Cleaned up 45 empty switches.

7.4. Executing FLATTEN pass (flatten design).
Using template $paramod\uart_tx\BAUD=104 for cells of type $paramod\uart_tx\BAUD=104.
Using template $paramod\uart_rx\BAUD=104 for cells of type $paramod\uart_rx\BAUD=104.
Using template ram_mem for cells of type ram_mem.
Using template hexa_to_bin for cells of type hexa_to_bin.
Using template bin_to_hexa for cells of type bin_to_hexa.
Using template decode_cmd for cells of type decode_cmd.
Using template cmd_control for cells of type cmd_control.
Using template $paramod\baudgen\BAUD=104 for cells of type $paramod\baudgen\BAUD=104.
Using template $paramod\baudgen_rx\BAUD=104 for cells of type $paramod\baudgen_rx\BAUD=104.
<suppressed ~10 debug messages>
No more expansions possible.
Deleting now unused module decode_cmd.
Deleting now unused module cmd_control.
Deleting now unused module hexa_to_bin.
Deleting now unused module bin_to_hexa.
Deleting now unused module ram_mem.
Deleting now unused module $paramod\baudgen_rx\BAUD=104.
Deleting now unused module $paramod\baudgen\BAUD=104.
Deleting now unused module $paramod\uart_rx\BAUD=104.
Deleting now unused module $paramod\uart_tx\BAUD=104.

7.5. Executing TRIBUF pass.

7.6. Executing DEMINOUT pass (demote inout ports to input or output).

7.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~78 debug messages>

7.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 30 unused cells and 196 unused wires.
<suppressed ~37 debug messages>

7.9. Executing CHECK pass (checking for obvious problems).
checking module protocol..
Warning: multiple conflicting drivers for protocol.\r_command_code [15]:
    port Q[15] of cell $procdff$560 ($dff)
    port Q[15] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [14]:
    port Q[14] of cell $procdff$560 ($dff)
    port Q[14] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [13]:
    port Q[13] of cell $procdff$560 ($dff)
    port Q[13] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [12]:
    port Q[12] of cell $procdff$560 ($dff)
    port Q[12] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [11]:
    port Q[11] of cell $procdff$560 ($dff)
    port Q[11] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [10]:
    port Q[10] of cell $procdff$560 ($dff)
    port Q[10] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [9]:
    port Q[9] of cell $procdff$560 ($dff)
    port Q[9] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [8]:
    port Q[8] of cell $procdff$560 ($dff)
    port Q[8] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [7]:
    port Q[7] of cell $procdff$560 ($dff)
    port Q[7] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [6]:
    port Q[6] of cell $procdff$560 ($dff)
    port Q[6] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [5]:
    port Q[5] of cell $procdff$560 ($dff)
    port Q[5] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [4]:
    port Q[4] of cell $procdff$560 ($dff)
    port Q[4] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [3]:
    port Q[3] of cell $procdff$560 ($dff)
    port Q[3] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [2]:
    port Q[2] of cell $procdff$560 ($dff)
    port Q[2] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [1]:
    port Q[1] of cell $procdff$560 ($dff)
    port Q[1] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\r_command_code [0]:
    port Q[0] of cell $procdff$560 ($dff)
    port Q[0] of cell $procdff$568 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [7]:
    port Q[7] of cell $procdff$559 ($dff)
    port Q[7] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [6]:
    port Q[6] of cell $procdff$559 ($dff)
    port Q[6] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [5]:
    port Q[5] of cell $procdff$559 ($dff)
    port Q[5] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [4]:
    port Q[4] of cell $procdff$559 ($dff)
    port Q[4] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [3]:
    port Q[3] of cell $procdff$559 ($dff)
    port Q[3] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [2]:
    port Q[2] of cell $procdff$559 ($dff)
    port Q[2] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [1]:
    port Q[1] of cell $procdff$559 ($dff)
    port Q[1] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\data_mem [0]:
    port Q[0] of cell $procdff$559 ($dff)
    port Q[0] of cell $procdff$566 ($dff)
Warning: multiple conflicting drivers for protocol.\mem_address [3]:
    port Q[3] of cell $procdff$558 ($dff)
    port Q[3] of cell $procdff$565 ($dff)
Warning: multiple conflicting drivers for protocol.\mem_address [2]:
    port Q[2] of cell $procdff$558 ($dff)
    port Q[2] of cell $procdff$565 ($dff)
Warning: multiple conflicting drivers for protocol.\mem_address [1]:
    port Q[1] of cell $procdff$558 ($dff)
    port Q[1] of cell $procdff$565 ($dff)
Warning: multiple conflicting drivers for protocol.\mem_address [0]:
    port Q[0] of cell $procdff$558 ($dff)
    port Q[0] of cell $procdff$565 ($dff)
Warning: multiple conflicting drivers for protocol.\wen:
    port Q[0] of cell $procdff$557 ($dff)
    port Q[0] of cell $procdff$564 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [7]:
    port Q[7] of cell $procdff$556 ($dff)
    port Q[7] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [6]:
    port Q[6] of cell $procdff$556 ($dff)
    port Q[6] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [5]:
    port Q[5] of cell $procdff$556 ($dff)
    port Q[5] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [4]:
    port Q[4] of cell $procdff$556 ($dff)
    port Q[4] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [3]:
    port Q[3] of cell $procdff$556 ($dff)
    port Q[3] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [2]:
    port Q[2] of cell $procdff$556 ($dff)
    port Q[2] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [1]:
    port Q[1] of cell $procdff$556 ($dff)
    port Q[1] of cell $procdff$563 ($dff)
Warning: multiple conflicting drivers for protocol.\tx_data [0]:
    port Q[0] of cell $procdff$556 ($dff)
    port Q[0] of cell $procdff$563 ($dff)
found and reported 37 problems.

7.10. Executing OPT pass (performing simple optimizations).

7.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
<suppressed ~87 debug messages>
Removed a total of 29 cells.

7.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port B of cell $procmux$345: \end_msg -> 1'1
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~39 debug messages>

7.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
    New input vector for $reduce_or cell $techmap\cctrl.$reduce_or$mods.v:156$134: { \RX0.data [0] \RX0.data [1] \RX0.data [2] \RX0.data [3] }
    New input vector for $reduce_and cell $techmap\cctrl.$reduce_and$mods.v:156$137: { \RX0.data [0] \RX0.data [1] \RX0.data [2] }
    New ctrl vector for $pmux cell $techmap\bth1.$procmux$247: { $techmap\bth1.$procmux$261_CMP $techmap\bth1.$procmux$260_CMP $techmap\bth1.$procmux$259_CMP $techmap\bth1.$procmux$258_CMP $techmap\bth1.$procmux$257_CMP $techmap\bth1.$procmux$256_CMP $techmap\bth1.$procmux$255_CMP $techmap\bth1.$procmux$254_CMP $techmap\bth1.$procmux$253_CMP $techmap\bth1.$procmux$252_CMP $techmap\bth1.$procmux$251_CMP $techmap\bth1.$procmux$250_CMP $techmap\bth1.$procmux$249_CMP $techmap\bth1.$procmux$248_CMP }
    New ctrl vector for $pmux cell $techmap\bth2.$procmux$247: { $techmap\bth2.$procmux$261_CMP $techmap\bth2.$procmux$260_CMP $techmap\bth2.$procmux$259_CMP $techmap\bth2.$procmux$258_CMP $techmap\bth2.$procmux$257_CMP $techmap\bth2.$procmux$256_CMP $techmap\bth2.$procmux$255_CMP $techmap\bth2.$procmux$254_CMP $techmap\bth2.$procmux$253_CMP $techmap\bth2.$procmux$252_CMP $techmap\bth2.$procmux$251_CMP $techmap\bth2.$procmux$250_CMP $techmap\bth2.$procmux$249_CMP $techmap\bth2.$procmux$248_CMP }
    New ctrl vector for $pmux cell $techmap\cctrl.$procmux$224: { $techmap\cctrl.$procmux$228_CMP $techmap\cctrl.$procmux$227_CMP $auto$opt_reduce.cc:132:opt_mux$576 }
    Consolidated identical input bits for $mux cell $techmap\ram_mem_wen01.$procmux$263:
      Old ports: A=8'00000000, B=8'11111111, Y=$techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119
      New ports: A=1'0, B=1'1, Y=$techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0]
      New connections: $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [7:1] = { $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] $techmap\ram_mem_wen01.$0$memwr$\mem$mods.v:24$115_EN[7:0]$119 [0] }
  Optimizing cells in module \protocol.
Performed a total of 6 changes.

7.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.10.6. Executing OPT_RMDFF pass (remove dff with constant values).
Removing $procdff$560 ($dff) from module protocol.
Removing $procdff$563 ($dff) from module protocol.
Removing $procdff$564 ($dff) from module protocol.
Removing $procdff$565 ($dff) from module protocol.
Removing $procdff$566 ($dff) from module protocol.
Replaced 5 DFF cells.

7.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Warning: Driver-driver conflict for \r_command_code [15] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [14] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [13] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [12] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [11] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [10] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [9] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [8] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [7] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [6] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [5] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [4] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [3] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [2] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [1] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \r_command_code [0] between cell $procdff$568.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [7] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [6] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [5] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [4] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [3] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [2] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [1] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \data_mem [0] between cell $procdff$559.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \mem_address [3] between cell $procdff$558.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \mem_address [2] between cell $procdff$558.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \mem_address [1] between cell $procdff$558.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \mem_address [0] between cell $procdff$558.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \wen between cell $procdff$557.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [7] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [6] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [5] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [4] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [3] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [2] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [1] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Warning: Driver-driver conflict for \tx_data [0] between cell $procdff$556.Q and constant 1'0 in protocol: Resolved using constant.
Removed 175 unused cells and 209 unused wires.
<suppressed ~195 debug messages>

7.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~7 debug messages>

7.10.9. Rerunning OPT passes. (Maybe there is more to do..)

7.10.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~19 debug messages>

7.10.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
Performed a total of 0 changes.

7.10.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.10.13. Executing OPT_RMDFF pass (remove dff with constant values).
Removing $techmap\TX0.$procdff$554 ($dff) from module protocol.
Removing $techmap\TX0.$procdff$555 ($dff) from module protocol.
Removing $techmap\ram_mem_wen01.$procdff$540 ($dff) from module protocol.
Removing $techmap\ram_mem_wen01.$procdff$541 ($dff) from module protocol.
Removing $techmap\ram_mem_wen01.$procdff$542 ($dff) from module protocol.
Replaced 5 DFF cells.

7.10.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 28 unused cells and 41 unused wires.
<suppressed ~38 debug messages>

7.10.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~1 debug messages>

7.10.16. Rerunning OPT passes. (Maybe there is more to do..)

7.10.17. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~18 debug messages>

7.10.18. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
    New ctrl vector for $pmux cell $techmap\TX0.$procmux$306: { $techmap\TX0.$eq$uart_tx.v:163$174_Y $techmap\TX0.$procmux$307_CMP }
  Optimizing cells in module \protocol.
Performed a total of 1 changes.

7.10.19. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.10.20. Executing OPT_RMDFF pass (remove dff with constant values).

7.10.21. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 0 unused cells and 1 unused wires.
<suppressed ~1 debug messages>

7.10.22. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.10.23. Rerunning OPT passes. (Maybe there is more to do..)

7.10.24. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~18 debug messages>

7.10.25. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
Performed a total of 0 changes.

7.10.26. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.10.27. Executing OPT_RMDFF pass (remove dff with constant values).

7.10.28. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.10.29. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.10.30. Finished OPT passes. (There is nothing left to do.)

7.11. Executing WREDUCE pass (reducing word size of cells).
Removed top 23 address bits (of 32) from memory init port protocol.$techmap\ram_mem_wen01.$meminit$\mem$mods.v:16$121 (ram_mem_wen01.mem).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\TX0.$ternary$uart_tx.v:164$177 ($mux).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\TX0.$ternary$uart_tx.v:163$175 ($mux).
Removed top 1 bits (of 2) from port B of cell protocol.$techmap\TX0.$eq$uart_tx.v:163$174 ($eq).
Removed top 31 bits (of 32) from port B of cell protocol.$techmap\TX0.$add$uart_tx.v:95$168 ($add).
Removed top 28 bits (of 32) from port Y of cell protocol.$techmap\TX0.$add$uart_tx.v:95$168 ($add).
Removed top 1 bits (of 2) from mux cell protocol.$techmap\RX0.$procmux$283 ($mux).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\RX0.$ternary$uart_rx.v:142$202 ($mux).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\RX0.$ternary$uart_rx.v:141$200 ($mux).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\RX0.$ternary$uart_rx.v:140$198 ($mux).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\RX0.$ternary$uart_rx.v:139$196 ($mux).
Removed top 1 bits (of 2) from port B of cell protocol.$techmap\RX0.$eq$uart_rx.v:139$195 ($eq).
Removed top 31 bits (of 32) from port B of cell protocol.$techmap\RX0.$add$uart_rx.v:71$185 ($add).
Removed top 28 bits (of 32) from port Y of cell protocol.$techmap\RX0.$add$uart_rx.v:71$185 ($add).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\TX0.BAUD0.$ternary$baudgen.v:52$209 ($mux).
Removed top 25 bits (of 32) from mux cell protocol.$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206 ($mux).
Removed top 31 bits (of 32) from port B of cell protocol.$techmap\TX0.BAUD0.$add$baudgen.v:44$205 ($add).
Removed top 25 bits (of 32) from port Y of cell protocol.$techmap\TX0.BAUD0.$add$baudgen.v:44$205 ($add).
Removed top 31 bits (of 32) from mux cell protocol.$techmap\RX0.baudgen0.$ternary$baudgen_rx.v:57$217 ($mux).
Removed top 1 bits (of 7) from port B of cell protocol.$techmap\RX0.baudgen0.$eq$baudgen_rx.v:57$215 ($eq).
Removed top 25 bits (of 32) from mux cell protocol.$techmap\RX0.baudgen0.$ternary$baudgen_rx.v:48$214 ($mux).
Removed top 31 bits (of 32) from port B of cell protocol.$techmap\RX0.baudgen0.$add$baudgen_rx.v:48$213 ($add).
Removed top 25 bits (of 32) from port Y of cell protocol.$techmap\RX0.baudgen0.$add$baudgen_rx.v:48$213 ($add).
Removed top 28 bits (of 32) from wire protocol.$techmap\RX0.$add$uart_rx.v:71$185_Y.
Removed top 1 bits (of 2) from wire protocol.$techmap\RX0.$procmux$283_Y.
Removed top 25 bits (of 32) from wire protocol.$techmap\RX0.baudgen0.$add$baudgen_rx.v:48$213_Y.
Removed top 25 bits (of 32) from wire protocol.$techmap\RX0.baudgen0.$ternary$baudgen_rx.v:48$214_Y.
Removed top 28 bits (of 32) from wire protocol.$techmap\TX0.$add$uart_tx.v:95$168_Y.

7.12. Executing PEEPOPT pass (run peephole optimizers).

7.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 0 unused cells and 13 unused wires.
<suppressed ~1 debug messages>

7.14. Executing SHARE pass (SAT-based resource sharing).

7.15. Executing TECHMAP pass (map to technology primitives).

7.15.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

7.15.2. Continuing TECHMAP pass.
Using template $paramod$99e5b0ecd4c7f9fb6cd3a733593eba894c42613f\_90_lut_cmp_ for cells of type $eq.
Using template $paramod$6816abac91a51b405c3de5bceb2855c03dd44485\_90_lut_cmp_ for cells of type $eq.
Using template $paramod$5c2d7617d568809e504489b04c3cf382857f302a\_90_lut_cmp_ for cells of type $eq.
Using template $paramod$0760830c1e6c196382cd2cb153e9fff2d84c061d\_90_lut_cmp_ for cells of type $eq.
Using template $paramod$dc6060208f0369ff43b26b7eee8e43bf61e4b025\_90_lut_cmp_ for cells of type $eq.
No more expansions possible.
<suppressed ~138 debug messages>

7.16. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~1 debug messages>

7.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 0 unused cells and 21 unused wires.
<suppressed ~1 debug messages>

7.18. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module protocol:
  creating $macc model for $techmap\RX0.$add$uart_rx.v:71$185 ($add).
  creating $macc model for $techmap\RX0.baudgen0.$add$baudgen_rx.v:48$213 ($add).
  creating $macc model for $techmap\TX0.$add$uart_tx.v:95$168 ($add).
  creating $macc model for $techmap\TX0.BAUD0.$add$baudgen.v:44$205 ($add).
  creating $alu model for $macc $techmap\TX0.BAUD0.$add$baudgen.v:44$205.
  creating $alu model for $macc $techmap\TX0.$add$uart_tx.v:95$168.
  creating $alu model for $macc $techmap\RX0.baudgen0.$add$baudgen_rx.v:48$213.
  creating $alu model for $macc $techmap\RX0.$add$uart_rx.v:71$185.
  creating $alu cell for $techmap\RX0.$add$uart_rx.v:71$185: $auto$alumacc.cc:474:replace_alu$594
  creating $alu cell for $techmap\RX0.baudgen0.$add$baudgen_rx.v:48$213: $auto$alumacc.cc:474:replace_alu$597
  creating $alu cell for $techmap\TX0.$add$uart_tx.v:95$168: $auto$alumacc.cc:474:replace_alu$600
  creating $alu cell for $techmap\TX0.BAUD0.$add$baudgen.v:44$205: $auto$alumacc.cc:474:replace_alu$603
  created 4 $alu and 0 $macc cells.

7.19. Executing OPT pass (performing simple optimizations).

7.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~17 debug messages>

7.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
Performed a total of 0 changes.

7.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.19.6. Executing OPT_RMDFF pass (remove dff with constant values).

7.19.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.19.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.19.9. Finished OPT passes. (There is nothing left to do.)

7.20. Executing FSM pass (extract and optimize FSM).

7.20.1. Executing FSM_DETECT pass (finding FSMs in design).
Not marking protocol.RX0.state as FSM state register:
    Users of register don't seem to benefit from recoding.
Not marking protocol.TX0.state as FSM state register:
    Users of register don't seem to benefit from recoding.

7.20.2. Executing FSM_EXTRACT pass (extracting FSM from design).

7.20.3. Executing FSM_OPT pass (simple optimizations of FSMs).

7.20.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.20.5. Executing FSM_OPT pass (simple optimizations of FSMs).

7.20.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

7.20.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

7.20.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

7.21. Executing OPT pass (performing simple optimizations).

7.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.21.3. Executing OPT_RMDFF pass (remove dff with constant values).

7.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.21.5. Finished fast OPT passes.

7.22. Executing MEMORY pass.

7.22.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).
Checking cell `$techmap\ram_mem_wen01.$memwr$\mem$mods.v:24$122' in module `\protocol': no (compatible) $dff found.

7.22.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.22.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

7.22.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.22.5. Executing MEMORY_COLLECT pass (generating $mem cells).
Collecting $memrd, $memwr and $meminit for memory `\ram_mem_wen01.mem' in module `\protocol':
  $techmap\ram_mem_wen01.$meminit$\mem$mods.v:16$121 ($meminit)
  $techmap\ram_mem_wen01.$memwr$\mem$mods.v:24$122 ($memwr)

7.23. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 1 unused cells and 0 unused wires.
<suppressed ~1 debug messages>

7.24. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).

7.25. Executing TECHMAP pass (map to technology primitives).

7.25.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M0'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M123'.
Successfully finished Verilog frontend.

7.25.2. Continuing TECHMAP pass.
No more expansions possible.

7.26. Executing ICE40_BRAMINIT pass.

7.27. Executing OPT pass (performing simple optimizations).

7.27.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~12 debug messages>

7.27.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.27.3. Executing OPT_RMDFF pass (remove dff with constant values).

7.27.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 0 unused cells and 5 unused wires.
<suppressed ~1 debug messages>

7.27.5. Finished fast OPT passes.

7.28. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

7.29. Executing OPT pass (performing simple optimizations).

7.29.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.29.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.29.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

7.29.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
    Consolidated identical input bits for $mux cell $techmap\TX0.$procmux$304:
      Old ports: A=2'10, B=2'00, Y=$techmap\TX0.$procmux$304_Y
      New ports: A=1'1, B=1'0, Y=$techmap\TX0.$procmux$304_Y [1]
      New connections: $techmap\TX0.$procmux$304_Y [0] = 1'0
  Optimizing cells in module \protocol.
    Consolidated identical input bits for $pmux cell $techmap\TX0.$procmux$306:
      Old ports: A=2'00, B={ 2'10 $techmap\TX0.$procmux$304_Y }, Y=$techmap\TX0.$procmux$306_Y
      New ports: A=1'0, B={ 1'1 $techmap\TX0.$procmux$304_Y [1] }, Y=$techmap\TX0.$procmux$306_Y [1]
      New connections: $techmap\TX0.$procmux$306_Y [0] = 1'0
  Optimizing cells in module \protocol.
    Consolidated identical input bits for $mux cell $techmap\TX0.$procmux$314:
      Old ports: A=2'00, B=$techmap\TX0.$procmux$306_Y, Y=$techmap\TX0.$0\state[1:0]
      New ports: A=1'0, B=$techmap\TX0.$procmux$306_Y [1], Y=$techmap\TX0.$0\state[1:0] [1]
      New connections: $techmap\TX0.$0\state[1:0] [0] = 1'0
  Optimizing cells in module \protocol.
Performed a total of 3 changes.

7.29.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.29.6. Executing OPT_RMDFF pass (remove dff with constant values).

7.29.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.29.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.29.9. Rerunning OPT passes. (Maybe there is more to do..)

7.29.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \protocol..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~12 debug messages>

7.29.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \protocol.
Performed a total of 0 changes.

7.29.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.29.13. Executing OPT_RMDFF pass (remove dff with constant values).

7.29.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.29.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.29.16. Finished OPT passes. (There is nothing left to do.)

7.30. Executing TECHMAP pass (map to technology primitives).

7.30.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

7.30.2. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

7.30.3. Continuing TECHMAP pass.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=4\Y_WIDTH=4 for cells of type $alu.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=7\Y_WIDTH=7 for cells of type $alu.
Using extmapper simplemap for cells of type $lut.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $dff.
Using template $paramod\_90_pmux\WIDTH=1\S_WIDTH=2 for cells of type $pmux.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $logic_and.
Using extmapper simplemap for cells of type $not.
Using template $paramod\_90_pmux\WIDTH=2\S_WIDTH=3 for cells of type $pmux.
Using extmapper simplemap for cells of type $eq.
Using extmapper simplemap for cells of type $pos.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $and.
No more expansions possible.
<suppressed ~141 debug messages>

7.31. Executing ICE40_OPT pass (performing simple optimizations).

7.31.1. Running ICE40 specific optimizations.

7.31.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~125 debug messages>

7.31.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
<suppressed ~18 debug messages>
Removed a total of 6 cells.

7.31.4. Executing OPT_RMDFF pass (remove dff with constant values).
Removing $auto$simplemap.cc:420:simplemap_dff$692 ($_DFF_P_) from module protocol.
Replaced 1 DFF cells.

7.31.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 47 unused cells and 115 unused wires.
<suppressed ~49 debug messages>

7.31.6. Rerunning OPT passes. (Removed registers in this run.)

7.31.7. Running ICE40 specific optimizations.
Optimized away SB_CARRY cell protocol.$auto$alumacc.cc:474:replace_alu$594.slice[0].carry: CO=\RX0.bitc [0]
Optimized away SB_CARRY cell protocol.$auto$alumacc.cc:474:replace_alu$597.slice[0].carry: CO=\RX0.baudgen0.divcounter [0]
Optimized away SB_CARRY cell protocol.$auto$alumacc.cc:474:replace_alu$600.slice[0].carry: CO=\TX0.bitc [0]
Optimized away SB_CARRY cell protocol.$auto$alumacc.cc:474:replace_alu$603.slice[0].carry: CO=\TX0.BAUD0.divcounter [0]
Mapping SB_LUT4 cell protocol.$auto$alumacc.cc:474:replace_alu$594.slice[1].adder back to logic.
Mapping SB_LUT4 cell protocol.$auto$alumacc.cc:474:replace_alu$597.slice[1].adder back to logic.
Mapping SB_LUT4 cell protocol.$auto$alumacc.cc:474:replace_alu$600.slice[1].adder back to logic.
Mapping SB_LUT4 cell protocol.$auto$alumacc.cc:474:replace_alu$603.slice[1].adder back to logic.

7.31.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~71 debug messages>

7.31.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.31.10. Executing OPT_RMDFF pass (remove dff with constant values).

7.31.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 0 unused cells and 16 unused wires.
<suppressed ~1 debug messages>

7.31.12. Rerunning OPT passes. (Removed registers in this run.)

7.31.13. Running ICE40 specific optimizations.

7.31.14. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.31.15. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.31.16. Executing OPT_RMDFF pass (remove dff with constant values).

7.31.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.31.18. Finished OPT passes. (There is nothing left to do.)

7.32. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

7.33. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Selected cell types for direct conversion:
  $_DFF_PP1_ -> $__DFFE_PP1
  $_DFF_PP0_ -> $__DFFE_PP0
  $_DFF_PN1_ -> $__DFFE_PN1
  $_DFF_PN0_ -> $__DFFE_PN0
  $_DFF_NP1_ -> $__DFFE_NP1
  $_DFF_NP0_ -> $__DFFE_NP0
  $_DFF_NN1_ -> $__DFFE_NN1
  $_DFF_NN0_ -> $__DFFE_NN0
  $_DFF_N_ -> $_DFFE_NP_
  $_DFF_P_ -> $_DFFE_PP_
Transforming FF to FF+Enable cells in module protocol:
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$672 to $_DFFE_PP_ for $0\leds[3:0] [0] -> \leds [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$673 to $_DFFE_PP_ for $0\leds[3:0] [1] -> \leds [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$674 to $_DFFE_PP_ for $0\leds[3:0] [2] -> \leds [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$675 to $_DFFE_PP_ for $0\leds[3:0] [3] -> \leds [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$678 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [0] -> \TX0.shifter [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$679 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [1] -> \TX0.shifter [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$680 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [2] -> \TX0.shifter [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$681 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [3] -> \TX0.shifter [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$682 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [4] -> \TX0.shifter [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$683 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [5] -> \TX0.shifter [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$684 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [6] -> \TX0.shifter [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$685 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [7] -> \TX0.shifter [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$686 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [8] -> \TX0.shifter [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$687 to $_DFFE_PP_ for $techmap\TX0.$0\shifter[9:0] [9] -> \TX0.shifter [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$688 to $_DFFE_PP_ for $techmap\TX0.$0\bitc[3:0] [0] -> \TX0.bitc [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$689 to $_DFFE_PP_ for $techmap\TX0.$0\bitc[3:0] [1] -> \TX0.bitc [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$690 to $_DFFE_PP_ for $techmap\TX0.$0\bitc[3:0] [2] -> \TX0.bitc [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$691 to $_DFFE_PP_ for $techmap\TX0.$0\bitc[3:0] [3] -> \TX0.bitc [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$754 to $_DFFE_PP_ for $techmap\RX0.$0\bitc[3:0] [0] -> \RX0.bitc [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$755 to $_DFFE_PP_ for $techmap\RX0.$0\bitc[3:0] [1] -> \RX0.bitc [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$756 to $_DFFE_PP_ for $techmap\RX0.$0\bitc[3:0] [2] -> \RX0.bitc [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$757 to $_DFFE_PP_ for $techmap\RX0.$0\bitc[3:0] [3] -> \RX0.bitc [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$759 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [1] -> \RX0.raw_data [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$760 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [2] -> \RX0.raw_data [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$761 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [3] -> \RX0.raw_data [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$762 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [4] -> \RX0.raw_data [4].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$763 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [5] -> \RX0.raw_data [5].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$764 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [6] -> \RX0.raw_data [6].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$765 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [7] -> \RX0.raw_data [7].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$766 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [8] -> \RX0.raw_data [8].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$767 to $_DFFE_PP_ for $techmap\RX0.$0\raw_data[9:0] [9] -> \RX0.raw_data [9].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$768 to $_DFFE_PP_ for $techmap\RX0.$0\data[7:0] [0] -> \RX0.data [0].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$769 to $_DFFE_PP_ for $techmap\RX0.$0\data[7:0] [1] -> \RX0.data [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$770 to $_DFFE_PP_ for $techmap\RX0.$0\data[7:0] [2] -> \RX0.data [2].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$771 to $_DFFE_PP_ for $techmap\RX0.$0\data[7:0] [3] -> \RX0.data [3].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$880 to $_DFFE_PP_ for $techmap\TX0.BAUD0.$0\divcounter[6:0] [1] -> \TX0.BAUD0.divcounter [1].
  converting $_DFF_P_ cell $auto$simplemap.cc:420:simplemap_dff$934 to $_DFFE_PP_ for $techmap\RX0.baudgen0.$0\divcounter[6:0] [1] -> \RX0.baudgen0.divcounter [1].

7.34. Executing TECHMAP pass (map to technology primitives).

7.34.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Successfully finished Verilog frontend.

7.34.2. Continuing TECHMAP pass.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
Using template \$_DFFE_PP_ for cells of type $_DFFE_PP_.
No more expansions possible.
<suppressed ~55 debug messages>

7.35. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~79 debug messages>

7.36. Executing SIMPLEMAP pass (map simple cells to gate primitives).

7.37. Executing ICE40_FFINIT pass (implement FF init values).
Handling FF init values in protocol.
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$939 (SB_DFF): \RX0.baudgen0.divcounter [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$676 (SB_DFF): \rstn = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$879 (SB_DFF): \TX0.BAUD0.divcounter [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$934 (SB_DFFE): \RX0.baudgen0.divcounter [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$938 (SB_DFF): \RX0.baudgen0.divcounter [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$933 (SB_DFF): \RX0.baudgen0.divcounter [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$937 (SB_DFF): \RX0.baudgen0.divcounter [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$882 (SB_DFF): \TX0.BAUD0.divcounter [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$883 (SB_DFF): \TX0.BAUD0.divcounter [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$881 (SB_DFF): \TX0.BAUD0.divcounter [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$884 (SB_DFF): \TX0.BAUD0.divcounter [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$885 (SB_DFF): \TX0.BAUD0.divcounter [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$935 (SB_DFF): \RX0.baudgen0.divcounter [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$936 (SB_DFF): \RX0.baudgen0.divcounter [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$880 (SB_DFFE): \TX0.BAUD0.divcounter [1] = 0

7.38. Executing ICE40_FFSSR pass (merge synchronous set/reset into FF cells).
Merging set/reset $_MUX_ cells into SB_FFs in protocol.
  Merging $auto$simplemap.cc:277:simplemap_mux$946 (A=1'1, B=$auto$wreduce.cc:455:run$580 [6], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$939 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$695 (A=1'1, B=\TX0.shifter [2], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$679 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$696 (A=1'1, B=\TX0.shifter [3], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$680 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$694 (A=1'1, B=\TX0.shifter [1], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$678 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$697 (A=1'1, B=\TX0.shifter [4], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$681 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$886 (A=1'1, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [0], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$879 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$698 (A=1'1, B=\TX0.shifter [5], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$682 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$699 (A=1'1, B=\TX0.shifter [6], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$683 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$700 (A=1'1, B=\TX0.shifter [7], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$684 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$701 (A=1'1, B=\TX0.shifter [8], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$685 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$941 (A=1'1, B=$auto$wreduce.cc:455:run$580 [1], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$934 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$732 (A=1'0, B=$techmap$techmap\TX0.$procmux$306.$ternary$/usr/bin/../share/yosys/techmap.v:445$734_Y, S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$693 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$702 (A=1'1, B=\TX0.shifter [9], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$686 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$779 (A=1'0, B=$auto$simplemap.cc:309:simplemap_lut$1106 [1], S=$auto$simplemap.cc:168:logic_reduce$826) into $auto$simplemap.cc:420:simplemap_dff$755 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$945 (A=1'1, B=$auto$wreduce.cc:455:run$580 [5], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$938 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$780 (A=1'0, B=$auto$wreduce.cc:455:run$577 [2], S=$auto$simplemap.cc:168:logic_reduce$826) into $auto$simplemap.cc:420:simplemap_dff$756 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$781 (A=1'0, B=$auto$wreduce.cc:455:run$577 [3], S=$auto$simplemap.cc:168:logic_reduce$826) into $auto$simplemap.cc:420:simplemap_dff$757 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$940 (A=1'1, B=$auto$wreduce.cc:455:run$580 [0], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$933 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$745 (A=1'0, B=\RX0.raw_data [1], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$768 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$746 (A=1'0, B=\RX0.raw_data [2], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$769 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$747 (A=1'0, B=\RX0.raw_data [3], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$770 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$748 (A=1'0, B=\RX0.raw_data [4], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$771 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$805 (A=1'0, B=$techmap$techmap\RX0.$procmux$275.$ternary$/usr/bin/../share/yosys/techmap.v:445$810_Y [1], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$777 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$778 (A=1'0, B=$auto$wreduce.cc:455:run$577 [0], S=$auto$simplemap.cc:168:logic_reduce$826) into $auto$simplemap.cc:420:simplemap_dff$754 (SB_DFFE).
  Merging $auto$simplemap.cc:277:simplemap_mux$944 (A=1'0, B=$auto$wreduce.cc:455:run$580 [4], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$937 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$889 (A=1'0, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [3], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$882 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$890 (A=1'0, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [4], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$883 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$888 (A=1'1, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [2], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$881 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$891 (A=1'1, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [5], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$884 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$892 (A=1'1, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [6], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$885 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$942 (A=1'1, B=$auto$wreduce.cc:455:run$580 [2], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$935 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$943 (A=1'0, B=$auto$wreduce.cc:455:run$580 [3], S=\RX0.bauden) into $auto$simplemap.cc:420:simplemap_dff$936 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$804 (A=1'0, B=$techmap$techmap\RX0.$procmux$275.$ternary$/usr/bin/../share/yosys/techmap.v:445$810_Y [0], S=\rstn) into $auto$simplemap.cc:420:simplemap_dff$776 (SB_DFF).
  Merging $auto$simplemap.cc:277:simplemap_mux$887 (A=1'1, B=$techmap\TX0.BAUD0.$ternary$baudgen.v:44$206_Y [1], S=\TX0.state [1]) into $auto$simplemap.cc:420:simplemap_dff$880 (SB_DFFE).

7.39. Executing ICE40_OPT pass (performing simple optimizations).

7.39.1. Running ICE40 specific optimizations.

7.39.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.
<suppressed ~37 debug messages>

7.39.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
<suppressed ~186 debug messages>
Removed a total of 62 cells.

7.39.4. Executing OPT_RMDFF pass (remove dff with constant values).

7.39.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..
Removed 34 unused cells and 339 unused wires.
<suppressed ~35 debug messages>

7.39.6. Rerunning OPT passes. (Removed registers in this run.)

7.39.7. Running ICE40 specific optimizations.

7.39.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module protocol.

7.39.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\protocol'.
Removed a total of 0 cells.

7.39.10. Executing OPT_RMDFF pass (remove dff with constant values).

7.39.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \protocol..

7.39.12. Finished OPT passes. (There is nothing left to do.)

7.40. Executing TECHMAP pass (map to technology primitives).

7.40.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

7.40.2. Continuing TECHMAP pass.
No more expansions possible.

7.41. Executing ABC pass (technology mapping using ABC).

7.41.1. Extracting gate netlist of module `\protocol' to `<abc-temp-dir>/input.blif'..
Extracted 104 gates and 145 wires to a netlist network with 39 inputs and 33 outputs.

7.41.1.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: + lutpack -S 1 
ABC: + dress 
ABC: Total number of equiv classes                =      38.
ABC: Participating nodes from both networks       =      94.
ABC: Participating nodes from the first network   =      37. (  88.10 % of nodes)
ABC: Participating nodes from the second network  =      57. ( 135.71 % of nodes)
ABC: Node pairs (any polarity)                    =      37. (  88.10 % of names can be moved)
ABC: Node pairs (same polarity)                   =      36. (  85.71 % of names can be moved)
ABC: Total runtime =     0.00 sec
ABC: + write_blif <abc-temp-dir>/output.blif 

7.41.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:       82
ABC RESULTS:        internal signals:       73
ABC RESULTS:           input signals:       39
ABC RESULTS:          output signals:       33
Removing temp directory.
Removed 0 unused cells and 100 unused wires.

7.42. Executing TECHMAP pass (map to technology primitives).

7.42.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Generating RTLIL representation for module `\$lut'.
Successfully finished Verilog frontend.

7.42.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=4\LUT=16'0001000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=1\LUT=2'01 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'1000000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000000000001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000000100000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'0001 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11101111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0100000000000000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1000 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'01001111 for cells of type $lut.
Using template $paramod\$lut\WIDTH=4\LUT=16'0000010111110011 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'00101100 for cells of type $lut.
Using template $paramod\$lut\WIDTH=3\LUT=8'11001010 for cells of type $lut.
Using template $paramod\$lut\WIDTH=2\LUT=4'1110 for cells of type $lut.
No more expansions possible.
<suppressed ~217 debug messages>
Removed 0 unused cells and 82 unused wires.

7.43. Executing HIERARCHY pass (managing design hierarchy).

7.43.1. Analyzing design hierarchy..
Top module:  \protocol

7.43.2. Analyzing design hierarchy..
Top module:  \protocol
Removed 0 unused modules.

7.44. Printing statistics.

=== protocol ===

   Number of wires:                108
   Number of wire bits:            330
   Number of public wires:          52
   Number of public wire bits:     194
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                128
     SB_CARRY                       14
     SB_DFF                          3
     SB_DFFE                        18
     SB_DFFESR                       8
     SB_DFFESS                      11
     SB_DFFSR                        7
     SB_DFFSS                        8
     SB_LUT4                        59

7.45. Executing CHECK pass (checking for obvious problems).
checking module protocol..
found and reported 0 problems.

7.46. Executing JSON backend.
